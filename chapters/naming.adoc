[[api-naming]]
[[urls]]
= REST - Resource paths and query parameters


[#129]
== {MUST} use kebab-case for path segments

Path segments are restricted to ASCII kebab-case strings matching regex `^[a-z][a-z\-0-9]*$`. 
The first character must be a lower case letter, and subsequent
characters can be a letter, or a dash(`-`), or a number.

Example:

[source,http]
----
/shipment-orders/{shipment-order-id}
----

*Hint:* kebab-case applies to concrete path segments and not necessarily the names of path parameters. 


[#130]
== {MUST} use snake_case (never camelCase) for query parameters

See also <<118>>.

[#134]
== {MUST} pluralize resource names

Usually, a collection of resource instances is provided (at least the API 
should be ready here). The special case of a _resource singleton_ must 
be modeled as a collection with cardinality 1 including definition of 
`maxItems` = `minItems` = 1 for the returned `array` structure 
to make the cardinality constraint explicit.

**Exception:** the _pseudo identifier_ `self` used to specify a resource endpoint 
where the resource identifier is provided by authorization information (see <<143>>).


[#135]
== {SHOULD} not use /api as base path

In most cases, all resources provided by a service are part of the
public API, and therefore should be made available under the root "/"
base path.

If the service should also support non-public, internal APIs
— for specific operational support functions, for example — we encourage 
you to maintain two different API specifications and provide
<<219, API audience>>. For both APIs, you should not use `/api` as base path.

We see API's base path as a part of deployment variant configuration.
Therefore, this information has to be declared in the
https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#server-object[server object].


[#136]
== {MUST} use normalized paths without empty path segments and trailing slashes

You must not specify paths with duplicate or trailing slashes, e.g.
`/customers//addresses` or `/customers/`. As a consequence, you must also not
specify or use path variables with empty string values.

*Reasoning:* Non standard paths have no clear semantics. As a result, behavior
for non standard paths varies between different HTTP infrastructure components
and libraries. This may leads to ambiguous and unexpected results during
request handling and monitoring.

We recommend to implement services robust against clients not following this
rule. All services *should* https://en.wikipedia.org/wiki/URI_normalization[normalize]
request paths before processing by removing duplicate and trailing slashes.
Hence, the following requests should refer to the same resource:

[source,http]
----
GET /orders/{order-id}
GET /orders/{order-id}/
GET /orders//{order-id}
----

**Note:** path normalization is not supported by all framework out-of-the-box.
Services are required to support at least the normalized path while rejecting
all alternatives paths, if failing to deliver the same resource.


[#137]
== {MUST} stick to conventional query parameters

If you provide query support for searching, sorting, filtering, and
paginating, you must stick to the following naming conventions:

* [[q]]{q}: default query parameter, e.g. used by browser tab completion;
  should have an entity specific alias, e.g. sku.
* [[sort]]{sort}: comma-separated list of fields (as defined by <<154>>) to
  define the sort order. To indicate sorting direction, fields may be prefixed
  with `+` (ascending) or `-` (descending), e.g. /sales-orders?sort=+id.
* [[fields]]{fields}: field name expression to retrieve only a subset of fields
  of a resource. See <<157>> below.
* [[embed]]{embed}: field name expression to expand or embedded sub-entities,
  e.g. inside of an article entity, expand silhouette code into the silhouette
  object. Implementing {embed} correctly is difficult, so do it with care.
  See <<158>> below.
* [[offset]]{offset}: numeric offset of the first element provided on a page
  representing a collection request. See <<pagination>> section below.
* [[cursor]]{cursor}: an opaque pointer to a page, never to be inspected or
  constructed by clients. It usually (encrypted) encodes the page position,
  i.e. the identifier of the first or last page element, the pagination
  direction, and the applied query filters to recreate the collection. See
  <<cursor-based-pagination>> or <<pagination>> section below.
* [[limit]]{limit}: client suggested limit to restrict the number of entries on
  a page. See <<pagination>> section below.

