[[performance]]
= Performance

[#155]
== {SHOULD} Reduce Bandwidth Needs and Improve Responsiveness

APIs should support techniques for reducing bandwidth based on client
needs. This holds for APIs that (might) have high payloads and/or are
used in high-traffic scenarios like the public Internet and
telecommunication networks. Typical examples are APIs used by mobile web
app clients with (often) less bandwidth connectivity. (Zalando is a
'Mobile First' company, so be mindful of this point.)

Common techniques include:

* <<156,gzip compression>>
* querying field filters to retrieve a subset of resource attributes
(see <<157>> below)
* paginate lists of data items (see <<pagination>> below)
* `ETag` and `If-(None-)Match` headers to avoid re-fetching of unchanged
resources (see <<182>>
* pagination for incremental access of larger (result) lists

Each of these items is described in greater detail below.

[#156]
== {SHOULD} Use gzip Compression

Compress the payload of your API’s responses with gzip, unless there’s a
good reason not to — for example, you are serving so many requests that
the time to compress becomes a bottleneck. This helps to transport data
faster over the network (fewer bytes) and makes frontends respond
faster.

Though gzip compression might be the default choice for server payload,
the server should also support payload without compression and its
client control via Accept-Encoding request header -- see also
http://tools.ietf.org/html/rfc7231#section-5.3.4[RFC 7231 Section
5.3.4]. The server should indicate used gzip compression via the
Content-Encoding header.

[#157]
== {SHOULD} Support Filtering of Resource Fields

Depending on your use case and payload size, you can significantly
reduce network bandwidth need by supporting filtering of returned entity
fields. Here, the client can determine the subset of fields he wants to
receive via the fields query parameter — example see
https://cloud.google.com/appengine/docs/python/taskqueue/rest/performance#partial-response[Google
AppEngine API's partial response]:

[[unfiltered]]
=== Unfiltered

[source,http]
----
GET http://api.example.org/resources/123 HTTP/1.1

HTTP/1.1 200 OK
Content-Type: application/json

{
  "id": "cddd5e44-dae0-11e5-8c01-63ed66ab2da5",
  "name": "John Doe",
  "address": "1600 Pennsylvania Avenue Northwest, Washington, DC, United States",
  "birthday": "1984-09-13",
  "partner": {
    "id": "1fb43648-dae1-11e5-aa01-1fbc3abb1cd0",
    "name": "Jane Doe",
    "address": "1600 Pennsylvania Avenue Northwest, Washington, DC, United States",
    "birthday": "1988-04-07"
  }
}
----

[[filtered]]
=== Filtered

[source,http]
----
GET http://api.example.org/resources/123?fields=(name,partner(name)) HTTP/1.1

HTTP/1.1 200 OK
Content-Type: application/json

{
  "name": "John Doe",
  "partner": {
    "name": "Jane Doe"
  }
}
----

As illustrated by this example, field filtering should be done via
request parameter "fields" with value range defined by the following
https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form[BNF] grammar.

[source,bnf]
----
<fields> ::= <negation> <fields_expression> | <fields_expression>

<negation> ::= "!"

<fields_expression> ::= "(" <field_set> ")"

<field_set> ::= <qualified_field> | <qualified_field> "," <field_set>

<qualified_field> ::= <field> | <field> <fields_expression>

<field> ::= <DASH_LETTER_DIGIT> | <DASH_LETTER_DIGIT> <field>

<DASH_LETTER_DIGIT> ::= <DASH> | <LETTER> | <DIGIT>

<DASH> ::= "-" | "_"

<LETTER> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z"

<DIGIT> ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
----

A `fields_expression` as defined by the grammar describes the properties
of an object, i.e. `(name)` returns only the `name` property of the root
object. `(name,partner(name))` returns the `name` and `partner`
properties where `partner` itself is also an object and only its `name`
property is returned.

Hint: OpenAPI doesn't allow you to formally specify whether depending on
a given parameter will return different parts of the specified result
schema. Explain this in English in the parameter description.

[#158]
== {SHOULD} Allow Optional Embedding of Sub-Resources

Embedding related resources (also know as _Resource expansion_) is a
great way to reduce the number of requests. In cases where clients know
upfront that they need some related resources they can instruct the
server to prefetch that data eagerly. Whether this is optimized on the
server, e.g. a database join, or done in a generic way, e.g. an HTTP
proxy that transparently embeds resources, is up to the implementation.

See <<137>> for naming, e.g. "embed" for steering of embedded
resource expansion. Please use the
https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form[BNF] grammar, as
already defined above for filtering, when it comes to an embedding query
syntax.

Embedding a sub-resource can possibly look like this where an order
resource has its order items as sub-resource (/order/\{orderId}/items):

[source,http]
----
GET /order/123?embed=(items) HTTP/1.1

{
  "id": "123",
  "_embedded": {
    "items": [
      {
        "position": 1,
        "sku": "1234-ABCD-7890",
        "price": {
          "amount": 71.99,
          "currency": "EUR"
        }
      }
    ]
  }
}
----

[#227]
== {MUST} Document Caching, if Supported

If an API is intended to support caching, it must take care to specify
this ability by defining the caching boundaries i.e. time-to-live and
cache constraints, by providing the `Cache-Control` and `Vary` headers
(Please read https://tools.ietf.org/html/rfc7234[RFC-7234] carefully).

Caching has to take many aspects into account, e.g. general cacheability
of response information, our guideline to protect endpoints using SSL
and <<104,OAuth authorization>>, resource update and invalidation rules,
existence of multiple consumer instances. As a consequence, caching is
in best case complex, in worst case inefficient. Thus, client side and
transparent HTTP caching should be avoided for RESTful APIs unless the
API designer has proven to know better.

As default, API providers should set the `Cache-Control: no-cache` header.

**Note:** There is no need to document this default setting, that is
attached to each response automatically by most frameworks. However, any
use deviating from this default must be sufficiently documented.

